use http::{StatusCode};
use actix_web::{web, HttpRequest, HttpResponse, Responder};
use actix_multipart::{Multipart, Field};
use serde::{Serialize, Deserialize};
use futures::{StreamExt, TryStreamExt};
use rand::{thread_rng, Rng};
use rand::distributions::Alphanumeric;

use crate::types;
use crate::database;
use crate::images;
use crate::files;

const DIMENSIONS_THUMB: u32 = 400;
const DIMENSIONS_PREVIEW: u32 = 1500;

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
struct CreatedResult {
	id: String
}

struct FormData {
	name: String,
	//filename: String,
	bytes: Vec<u8>
}

pub async fn route_index() -> impl Responder {
	format!("Hello world!")
}

pub async fn route_get_albums() -> impl Responder {
	web::Json(database::album::get_all())
}

pub async fn route_get_album(req: HttpRequest) -> impl Responder {
	let album_id = req.match_info().get("album_id").unwrap();
	let result = database::album::get(album_id);

	match result {
		Some(album) => {
			let mut ids: Vec<&str> = Vec::new();

			for id in album.photos.iter() {
				ids.push(&id[..]);
			}
			
			let response = types::ClientAlbum {
				title: Some(album.title),
				thumb_photo: {
					if let Some(thumb_photo_id) = album.thumb_photo_id { 
						let result = database::photo::get(&thumb_photo_id);
						match result {
							Some(thumb_photo) => Some(thumb_photo.to_client_photo()),
							None => None
						}
					} else { 
						None 
					}
				},
				photos: {
					let result = database::photo::get_many(&ids);
					if let Some(photos) = result {
						let mut result_photos = Vec::new();
						for photo in photos {
							result_photos.push(photo.to_client_photo());
						}
	
						Some(result_photos)
					} else {
						None
					}
				}
			};
			web::Json(response)
		},
		None => panic!("no album") // How to return HTTP 404?
	}
}

pub async fn route_create_album(mut album: web::Json<types::Album>) -> impl Responder {
	album.id = String::new();	// Make sure id is generated by database, ignoring what client sent us.
	let album_id = database::album::create(&album);

	web::Json(CreatedResult{id: album_id.unwrap()})
}

pub async fn route_update_album(req: HttpRequest, album: web::Json<types::UpdateAlbum>) -> impl Responder {
	let album_id = req.match_info().get("album_id").unwrap();

	// TODO: Verify if all photoIds & thumbPhotoId are valid.

	let result = database::album::update(&album_id, &album);
	match result {
		Some(_) => HttpResponse::build(StatusCode::OK),
		None => HttpResponse::build(StatusCode::NOT_FOUND)
	}
}

pub async fn route_delete_album(req: HttpRequest) -> impl Responder {
	let album_id = req.match_info().get("album_id").unwrap();
	let result = database::album::delete(&album_id);

	match result {
		Some(_) => HttpResponse::build(StatusCode::OK),
		None => HttpResponse::build(StatusCode::NOT_FOUND)
	}
}

pub async fn route_get_photos() -> impl Responder {
	web::Json(database::photo::get_all())
}

pub async fn route_delete_photos(photo_ids: web::Json<Vec<String>>) -> impl Responder {
	let mut ids: Vec<&str> = Vec::new();

	for id in photo_ids.iter() {
		ids.push(&id[..]);
	}

	// TODO: Also delete photos from all albums they are a part of.
	let result = database::photo::delete_many(&ids);

	match result {
		Some(_) => HttpResponse::build(StatusCode::OK),
		None => HttpResponse::build(StatusCode::NOT_FOUND)
	}
}

pub async fn route_get_photo(req: HttpRequest) -> impl Responder {
	let photo_id = req.match_info().get("photo_id").unwrap();
	let result = database::photo::get(photo_id);

	match result {
		Some(photo) => web::Json(photo),
		None => panic!("no photo") // How to return HTTP 404, if 'good' path returns json?
	}
}

pub async fn route_download_photo_thumbnail(req: HttpRequest) -> impl Responder {
	let _photo_id = req.match_info().get("photo_id").unwrap();
	let result = database::photo::get(&_photo_id);

	match result {
		Some(photo_info) => serve_photo(&photo_info.path_thumbnail),
		None => panic!("File not found")
	}
}

pub async fn route_download_photo_preview(req: HttpRequest) -> impl Responder {
	let _photo_id = req.match_info().get("photo_id").unwrap();
	let result = database::photo::get(&_photo_id);

	match result {
		Some(photo_info) => serve_photo(&photo_info.path_preview),
		None => panic!("File not found")
	}
}

pub async fn route_download_photo_original(req: HttpRequest) -> impl Responder {
	let _photo_id = req.match_info().get("photo_id").unwrap();
	let result = database::photo::get(&_photo_id);

	match result {
		Some(photo_info) => serve_photo(&photo_info.path_original),
		None => panic!("File not found")
	}
}

fn serve_photo(path: &str) -> impl Responder {
	let result = files::get_photo(path);

	match result {
		Some(file_bytes) => {
			HttpResponse::Ok()
				.content_type("image/jpeg")
				.body(file_bytes)
		},
		None => panic!("Error reading file content from disk, or file not found")
	}
}

pub async fn route_upload_photo(payload: Multipart) -> impl Responder {
	let form_data = get_form_data(payload).await;

	let mut files_iter = form_data.iter().filter(|d| d.name == "file");
	let file_option = files_iter.next();
	let remaining_files = files_iter.count();

	if remaining_files > 0 {
		// HttpResponse::BadRequest() //(StatusCode::BAD_REQUEST)
		panic!("Request contains more than one file.")
	}

	match file_option {
		Some(file) => {
			let photo = create_photo(&file.bytes);
			let photo_id = database::photo::create(&photo).unwrap();
			HttpResponse::Ok().json(CreatedResult{id: photo_id})
		},
		None => panic!("Request contains no file.")
	}
}

pub async fn route_delete_photo(req: HttpRequest) -> impl Responder {
	let photo_id = req.match_info().get("photo_id").unwrap();
	let result = database::photo::delete(&photo_id);
	
	match result {
		Some(_) => HttpResponse::build(StatusCode::OK),
		None => HttpResponse::build(StatusCode::NOT_FOUND)
	}
}

// Gets all fields from multipart payload.
async fn get_form_data(mut payload: Multipart) -> Vec<FormData> {
	let mut form_data: Vec<FormData> = Vec::new();

	while let Ok(Some(field)) = payload.try_next().await {
		
		let content_disposition = field.content_disposition().unwrap();
		//let content_type = field.content_type();
		let key = content_disposition.get_name().unwrap();
		//let filename = content_disposition.get_filename().unwrap_or_default();

		let field_bytes = get_form_field_bytes(field).await;
		form_data.push(FormData{
			name: key.to_string(), 
			//filename: filename.to_string(),
			bytes: field_bytes
		});
	}

	form_data
}

// Gets the bytes of a single multipart field.
async fn get_form_field_bytes(mut field: Field) -> Vec<u8> {
	let mut field_bytes: Vec<u8> = Vec::new();
				
	while let Some(chunk) = field.next().await {
		let chunk_bytes = chunk.unwrap();

		for byte in chunk_bytes {
			field_bytes.push(byte);
		}
	}

	field_bytes
}

fn create_photo(photo_bytes: &Vec<u8>) -> types::Photo {
	// Generate a random filename
	let mut filename: String = thread_rng()
		.sample_iter(&Alphanumeric)
		.take(20)
		.collect();
	filename.push_str(&".jpg");

	let thumbnail_file_name = format!("thumb_{}", filename);
	let preview_file_name = format!("preview_{}", filename);

	let thumbnail_image_bytes = images::resize_image(photo_bytes, DIMENSIONS_THUMB);
	let preview_image_bytes = images::resize_image(photo_bytes, DIMENSIONS_PREVIEW);
	
	let original_path = files::store_photo(&filename.to_string(), photo_bytes);
	let thumbnail_path = files::store_photo(&thumbnail_file_name.to_string(), &thumbnail_image_bytes);
	let preview_path = files::store_photo(&preview_file_name.to_string(), &preview_image_bytes);

	let (photo_width, photo_height) = images::get_image_dimensions(photo_bytes);

	types::Photo {
		id: String::new(),
		name: filename,
		width: photo_width,
		height: photo_height,
		path_thumbnail: thumbnail_path,
		path_preview: preview_path,
		path_original: original_path
	}
}